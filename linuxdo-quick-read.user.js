// ==UserScript==
// @name         LinuxDo ËæÖÂä©Â∑•ÂÖ∑
// @namespace    http://tampermonkey.net/
// @version      7.0
// @description  LinuxDo ËÆ∫ÂùõËæÖÂä©Â∑•ÂÖ∑ÔºöÂø´ÈÄüÊ†áËÆ∞Êú™ËØªÂõûÂ§ç‰∏∫Â∑≤ËØªÔºåÊîØÊåÅÈöèÊú∫ÂÜ∑Èó®Â∏ñÂ≠êÊµèËßà
// @author       Assistant
// @match        https://linux.do/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function() {
    'use strict';

    // üö´ ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÈò≤Ê≠¢Âú®iframe‰∏≠ÊâßË°åËÑöÊú¨
    if (window !== window.top) {
        console.log('üö´ Ê£ÄÊµãÂà∞Âú®iframe‰∏≠ÔºåË∑≥ËøáLinuxDoËæÖÂä©Â∑•ÂÖ∑ËÑöÊú¨ÊâßË°å');
        return;
    }

    console.log('‚úÖ Âú®‰∏ªÁ™óÂè£‰∏≠ÔºåÂºÄÂßãÊâßË°åLinuxDoËæÖÂä©Â∑•ÂÖ∑ËÑöÊú¨');

    // Â∫îÁî®Áä∂ÊÄÅÁÆ°ÁêÜ
    const state = {
        isProcessing: false,
        isBrowsing: false,
        speed: 'NORMAL',
        isAutoMode: true,
        isCollapsed: false,
        unreadCount: 20,
        concurrentThreads: 3,  // Âπ∂ÂèëÁ∫øÁ®ãÊï∞
        lastUrl: location.href,
        lastTopicId: null,  // Ê∑ªÂä†ÊúÄÂêéËÆøÈóÆÁöÑËØùÈ¢òID
        // ÊÄßËÉΩ‰ºòÂåñÁõ∏ÂÖ≥
        urlCheckInterval: null,
        eventListeners: [],
        cachedElements: new Map()
    };

    // ÈÖçÁΩÆ
    const config = {
        speeds: {
            NORMAL: { delay: 100, name: 'Ê≠£Â∏∏' },
            FAST: { delay: 50, name: 'Âø´ÈÄü' },
            TURBO: { delay: 20, name: 'ÊûÅÈÄü' }
        },
        storage: {
            speed: 'linuxdo-speed',
            autoMode: 'linuxdo-auto-mode',
            collapsed: 'linuxdo-collapsed',
            unreadCount: 'linuxdo-unread-count',
            concurrentThreads: 'linuxdo-concurrent-threads'
        }
    };

    // Â∏∏ÈáèÂÆö‰πâ
    const CONSTANTS = {
        DELAYS: {
            INIT: 100,
            REINIT: 300,
            AUTO_CHECK: 500,
            STATUS_UPDATE: 200
        },
        TIMEOUTS: {
            IFRAME_LOAD: 10000,
            IFRAME_BROWSE: 8000,
            IFRAME_STAY: 3000
        },
        IFRAME_STYLE: 'position:fixed;top:-1000px;left:-1000px;width:1px;height:1px;opacity:0;pointer-events:none;'
    };

    // Â∑•ÂÖ∑ÂáΩÊï∞
    const utils = {
        // ÈöèÊú∫Êâì‰π±Êï∞ÁªÑ
        shuffle: (array) => {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        },

        // Âª∂ËøüÂáΩÊï∞
        delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)),

        // Ëé∑ÂèñÈ°µÈù¢Á±ªÂûã - ÁÆÄÂåñÈÄªËæëÔºåÂú®linux.doÂüüÂêç‰∏ãÊòæÁ§∫ÂÖ®ÈÉ®ÂäüËÉΩ
        getPageType: () => {
            const path = location.pathname;

            // ËØùÈ¢òÈ°µÈù¢
            if (path.includes('/t/topic/')) return 'topic';

            // ÂÖ∂‰ªñÈ°µÈù¢ÈÉΩËßÜ‰∏∫ÂàóË°®È°µÈù¢ÔºåÊòæÁ§∫ÂÖ®ÈÉ®ÂäüËÉΩ
            return 'list';
        },

        // ÊèêÂèñËØùÈ¢òID
        getTopicId: () => {
            const path = location.pathname;
            const match = path.match(/\/t\/topic\/(\d+)/);
            return match ? match[1] : null;
        },

        // Áªü‰∏ÄÁöÑiframeÂàõÂª∫ÂáΩÊï∞
        createIframe: (url, timeout = CONSTANTS.TIMEOUTS.IFRAME_LOAD) => {
            return new Promise((resolve, reject) => {
                const iframe = document.createElement('iframe');
                iframe.style.cssText = CONSTANTS.IFRAME_STYLE;
                iframe.src = url;
                document.body.appendChild(iframe);

                const timeoutId = setTimeout(() => {
                    utils.cleanupIframe(iframe);
                    reject(new Error(`iframeÂä†ËΩΩË∂ÖÊó∂: ${url}`));
                }, timeout);

                iframe.onload = () => {
                    clearTimeout(timeoutId);
                    resolve(iframe);
                };

                iframe.onerror = () => {
                    clearTimeout(timeoutId);
                    utils.cleanupIframe(iframe);
                    reject(new Error(`iframeÂä†ËΩΩÂ§±Ë¥•: ${url}`));
                };
            });
        },

        // Áªü‰∏ÄÁöÑiframeÊ∏ÖÁêÜÂáΩÊï∞
        cleanupIframe: (iframe) => {
            try {
                if (iframe && iframe.parentNode) {
                    iframe.parentNode.removeChild(iframe);
                }
            } catch (e) {
                console.warn('iframeÊ∏ÖÁêÜÂ§±Ë¥•:', e);
            }
        },

        // Èò≤ÊäñÂáΩÊï∞
        debounce: (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },

        // Â≠òÂÇ®Êìç‰Ωú
        storage: {
            get: (key, defaultValue) => {
                const value = localStorage.getItem(config.storage[key]);
                return value !== null ? JSON.parse(value) : defaultValue;
            },
            set: (key, value) => localStorage.setItem(config.storage[key], JSON.stringify(value))
        }
    };

    // Áä∂ÊÄÅÁÆ°ÁêÜ
    const stateManager = {
        init() {
            state.speed = utils.storage.get('speed', 'NORMAL');
            state.isAutoMode = utils.storage.get('autoMode', true);
            state.isCollapsed = utils.storage.get('collapsed', false);
            state.unreadCount = utils.storage.get('unreadCount', 20);
            state.concurrentThreads = utils.storage.get('concurrentThreads', 3);
        },

        setSpeed(speed) {
            if (config.speeds[speed]) {
                state.speed = speed;
                utils.storage.set('speed', speed);
            }
        },

        setAutoMode(auto) {
            state.isAutoMode = auto;
            utils.storage.set('autoMode', auto);
            ui.updateModeButtons();

            if (auto && utils.getPageType() === 'topic' && !state.isProcessing) {
                setTimeout(() => topicProcessor.checkAndProcess(), CONSTANTS.DELAYS.AUTO_CHECK);
            }
        },

        toggleCollapsed() {
            state.isCollapsed = !state.isCollapsed;
            utils.storage.set('collapsed', state.isCollapsed);
            ui.updateCollapsed();
        }
    };

    // ËØùÈ¢òÂ§ÑÁêÜÂô®
    const topicProcessor = {
        getTopicInfo() {
            const match = location.pathname.match(/\/t\/topic\/(\d+)(?:\/(\d+))?/);
            return match ? {
                topicId: match[1],
                currentPosition: match[2] ? parseInt(match[2]) : 1
            } : null;
        },

        getTotalReplies() {
            const timelineReplies = document.querySelector('.timeline-replies');
            if (timelineReplies) {
                const match = timelineReplies.textContent.match(/(\d+)\s*\/\s*(\d+)/);
                if (match) return { current: parseInt(match[1]), total: parseInt(match[2]) };
            }
            const posts = document.querySelectorAll('article[data-post-id], [data-post-number]');
            return { current: posts.length, total: posts.length };
        },

        getRepliesNeedMarking() {
            const topicInfo = this.getTopicInfo();
            if (!topicInfo) return [];

            const replyInfo = this.getTotalReplies();

            const replies = [];
            for (let i = topicInfo.currentPosition + 1; i <= replyInfo.total; i++) {
                replies.push({ id: i.toString(), position: i });
            }
            return replies;
        },

        async markPostAsRead(postId, topicId, csrfToken) {
            try {
                const response = await fetch('/topics/timings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({
                        topic_id: parseInt(topicId),
                        topic_time: Math.floor(Date.now() / 1000),
                        timings: { [`${postId}`]: 3000 }
                    })
                });
                return response.ok;
            } catch (error) {
                console.error(`Ê†áËÆ∞Â∏ñÂ≠ê ${postId} Â§±Ë¥•:`, error);
                return false;
            }
        },

        async processUnread() {
            if (state.isProcessing) return;
            state.isProcessing = true;
            ui.updateStatus('Â§ÑÁêÜ‰∏≠...', '#007cbb');
            ui.updateStopButton(true);

            const replies = this.getRepliesNeedMarking();
            const topicInfo = this.getTopicInfo();
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

            if (!topicInfo || !csrfToken || replies.length === 0) {
                ui.updateStatus(replies.length === 0 ? '‚úÖ Êó†ÈúÄÊ†áËÆ∞' : '‚ùå Ëé∑Âèñ‰ø°ÊÅØÂ§±Ë¥•', replies.length === 0 ? 'green' : 'red');
                state.isProcessing = false;
                ui.updateStopButton(false);
                return;
            }

            const speedConfig = config.speeds[state.speed];
            let successCount = 0;

            for (let i = 0; i < replies.length && state.isProcessing; i++) {
                const reply = replies[i];
                ui.updateStatus(`${i + 1}/${replies.length} (${speedConfig.name})`, '#007cbb');

                const success = await this.markPostAsRead(reply.id, topicInfo.topicId, csrfToken);
                if (success) successCount++;

                if (i < replies.length - 1 && state.isProcessing) {
                    await utils.delay(speedConfig.delay);
                }
            }

            ui.updateStatus(state.isProcessing ? `‚úÖ ÂÆåÊàê ${successCount}‰∏™` : '‚èπÔ∏è Â∑≤ÂÅúÊ≠¢',
                           state.isProcessing ? 'green' : 'orange');
            state.isProcessing = false;
            ui.updateStopButton(false);
        },

        checkAndProcess() {
            if (state.isProcessing) return;
            const replies = this.getRepliesNeedMarking();
            if (replies.length === 0) {
                ui.updateStatus('‚úÖ Êó†ÈúÄÊ†áËÆ∞', 'green');
            } else {
                ui.updateStatus(`ÂèëÁé∞ ${replies.length} ‰∏™ÂõûÂ§ç`, '#007cbb');
                setTimeout(() => {
                    if (!state.isProcessing && location.href === state.lastUrl) {
                        this.processUnread();
                    }
                }, 1000);
            }
        }
    };

    // ÂÜ∑Èó®Â∏ñÂ≠êÊµèËßàÂô®
    const coldTopicBrowser = {

        // ‰ªéÈ°µÈù¢ÊñáÊ°£‰∏≠ÊèêÂèñËØùÈ¢òÔºàÂåÖÂê´ÊµèËßàÈáèÂíåÂõûÂ§çÊï∞‰ø°ÊÅØÔºâ
        extractTopicsFromPage(doc, topics) {
            const topicRows = doc.querySelectorAll('table tbody tr');
            console.log(`‰ªéÈ°µÈù¢ÊèêÂèñÂà∞ ${topicRows.length} Ë°åÊï∞ÊçÆ`);

            topicRows.forEach((row) => {
                const titleLinks = row.querySelectorAll('a[href*="/t/topic/"]');
                let mainTitleLink = null;

                // ÊâæÂà∞‰∏ªË¶ÅÁöÑËØùÈ¢òÊ†áÈ¢òÈìæÊé•
                for (let link of titleLinks) {
                    if (link.closest('h2') || (!mainTitleLink && link.textContent.trim().length > 5)) {
                        mainTitleLink = link;
                        break;
                    }
                }

                if (mainTitleLink && !mainTitleLink.href.includes('#')) {
                    const title = mainTitleLink.textContent.trim();
                    if (title) {
                        const url = mainTitleLink.href.startsWith('http') ?
                                   mainTitleLink.href :
                                   `https://linux.do${mainTitleLink.href}`;

                        // ÊèêÂèñÊµèËßàÈáè‰ø°ÊÅØ
                        let views = 0;
                        const viewsElement = row.querySelector('.views .number');
                        if (viewsElement) {
                            const viewsText = viewsElement.textContent.trim();
                            // Â§ÑÁêÜ k Âçï‰ΩçÔºàÂ¶Ç 1.2k = 1200Ôºâ
                            if (viewsText.includes('k')) {
                                views = Math.floor(parseFloat(viewsText) * 1000);
                            } else {
                                views = parseInt(viewsText) || 0;
                            }
                        }

                        // ÊèêÂèñÂõûÂ§çÊï∞‰ø°ÊÅØ
                        let replies = 0;
                        const repliesElement = row.querySelector('.posts .number');
                        if (repliesElement) {
                            replies = parseInt(repliesElement.textContent.trim()) || 0;
                        }

                        topics.push({
                            title: title.length > 40 ? title.substring(0, 40) + '...' : title,
                            url: url,
                            views: views,
                            replies: replies
                        });
                    }
                }
            });
        },

        // ÈÄöËøáiframeËé∑ÂèñÊåáÂÆöÈ°µÈù¢ÁöÑËØùÈ¢ò
        async getTopicsFromUrl(url) {
            try {
                const iframe = await utils.createIframe(url);
                const doc = iframe.contentDocument || iframe.contentWindow.document;
                const topics = [];
                this.extractTopicsFromPage(doc, topics);
                utils.cleanupIframe(iframe);
                return topics;
            } catch (error) {
                console.error(`Ëé∑ÂèñÈ°µÈù¢ËØùÈ¢òÂ§±Ë¥•: ${url}`, error);
                throw error;
            }
        },

        // Âà§Êñ≠ÊòØÂê¶‰∏∫ÂÜ∑Èó®Â∏ñÂ≠ê
        isColdTopic(topic) {
            const views = topic.views || 0;
            const replies = topic.replies || 0;

            // ÂÜ∑Èó®Â∏ñÂ≠êÊ†áÂáÜÔºöÊµèËßàÈáè5-800ÔºåÂõûÂ§çÊï∞0-30
            return views >= 5 && views <= 800 && replies >= 0 && replies <= 30;
        },

        async getColdTopics() {
            const allTopics = [];
            const coldTopics = [];

            try {
                if (location.pathname.includes('/latest')) {
                    // Áõ¥Êé•‰ªéÂΩìÂâçÈ°µÈù¢Ëé∑Âèñ
                    console.log('‰ªéÂΩìÂâçÊúÄÊñ∞È°µÈù¢Ëé∑ÂèñÂ∏ñÂ≠ê');
                    this.extractTopicsFromPage(document, allTopics);
                } else {
                    // ‰ΩøÁî®ÈöêËóèiframeËé∑ÂèñÊúÄÊñ∞È°µÈù¢ÔºåÊîØÊåÅÂ§öÈ°µËé∑Âèñ
                    ui.updateStatus('Ê≠£Âú®Ëé∑ÂèñÊúÄÊñ∞Â∏ñÂ≠ê...', '#007cbb');
                    console.log('ÈÄöËøáÈöêËóèiframeËé∑ÂèñÊúÄÊñ∞È°µÈù¢');

                    // Â∞ùËØïËé∑ÂèñÂ§öÈ°µÊï∞ÊçÆÔºåÊúÄÂ§öËé∑Âèñ5È°µ‰ª•Ëé∑ÂæóÊõ¥Â§öÊ†∑Êú¨
                    const maxPages = 5;
                    for (let page = 0; page < maxPages && allTopics.length < 200; page++) {
                        try {
                            const url = page === 0 ? '/latest?per_page=50' : `/latest?page=${page}&per_page=50`;
                            ui.updateStatus(`Ê≠£Âú®Ëé∑ÂèñÁ¨¨ ${page + 1} È°µÊúÄÊñ∞Â∏ñÂ≠ê...`, '#007cbb');

                            const pageTopics = await this.getTopicsFromUrl(url);
                            console.log(`Á¨¨ ${page + 1} È°µËé∑ÂèñÂà∞ ${pageTopics.length} ‰∏™Â∏ñÂ≠ê`);

                            if (pageTopics.length === 0) {
                                console.log(`Á¨¨ ${page + 1} È°µÊ≤°ÊúâÊõ¥Â§öÂ∏ñÂ≠êÔºåÂÅúÊ≠¢Ëé∑Âèñ`);
                                break;
                            }

                            allTopics.push(...pageTopics);

                            // È°µÈù¢Èó¥Ê∑ªÂä†Â∞èÂª∂Ëøü
                            if (page < maxPages - 1) {
                                await utils.delay(CONSTANTS.DELAYS.AUTO_CHECK);
                            }
                        } catch (error) {
                            console.error(`Ëé∑ÂèñÁ¨¨ ${page + 1} È°µÂ§±Ë¥•:`, error);
                            if (page === 0) {
                                // Â¶ÇÊûúÁ¨¨‰∏ÄÈ°µÂ∞±Â§±Ë¥•‰∫ÜÔºåÊäõÂá∫ÈîôËØØ
                                throw error;
                            }
                            // ÂÖ∂‰ªñÈ°µÈù¢Â§±Ë¥•ÂàôÁªßÁª≠
                            break;
                        }
                    }
                }

                console.log('ÊÄªÂÖ±Ëé∑ÂèñÂà∞Â∏ñÂ≠ê:', allTopics.length);

                // Á≠õÈÄâÂÜ∑Èó®Â∏ñÂ≠ê
                for (const topic of allTopics) {
                    if (this.isColdTopic(topic)) {
                        coldTopics.push(topic);
                    }
                }

                console.log('Á≠õÈÄâÂá∫ÂÜ∑Èó®Â∏ñÂ≠ê:', coldTopics.length);

                // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞‰ªª‰ΩïÂÜ∑Èó®Â∏ñÂ≠êÔºåÊèê‰æõÁî®Êà∑ÊèêÁ§∫
                if (coldTopics.length === 0) {
                    ui.updateStatus('‚ùå Êú™ÊâæÂà∞ÂÜ∑Èó®Â∏ñÂ≠ê', 'red');
                    console.log('Âª∫ËÆÆÔºöÂ∞ùËØïË∞ÉÊï¥ÂÜ∑Èó®Â∏ñÂ≠êÁöÑÁ≠õÈÄâÊ†áÂáÜ');
                }
            } catch (error) {
                console.error('Ëé∑ÂèñÂÜ∑Èó®Â∏ñÂ≠êÂ§±Ë¥•:', error);
                ui.updateStatus(`‚ùå Ëé∑ÂèñÂ§±Ë¥•: ${error.message}`, 'red');
            }

            return utils.shuffle(coldTopics);
        },

        async browseTopicInIframe(topic) {
            try {
                const iframe = await utils.createIframe(topic.url, CONSTANTS.TIMEOUTS.IFRAME_BROWSE);
                // Ê®°ÊãüÊµèËßàÂÅúÁïôÊó∂Èó¥
                await utils.delay(CONSTANTS.TIMEOUTS.IFRAME_STAY);
                utils.cleanupIframe(iframe);
            } catch (error) {
                console.warn(`ÊµèËßàËØùÈ¢òÂ§±Ë¥•: ${topic.url}`, error);
                // Âç≥‰ΩøÂ§±Ë¥•‰πüÁªßÁª≠Ôºå‰∏ç‰∏≠Êñ≠Êï¥‰∏™ÊµèËßàÊµÅÁ®ã
            }
        },

        // Â§öÁ∫øÁ®ãÊµèËßàËØùÈ¢ò
        async browseTopicsConcurrently(topics, startIndex, endIndex) {
            const promises = [];
            const actualEnd = Math.min(endIndex, topics.length);

            for (let i = startIndex; i < actualEnd && state.isBrowsing; i++) {
                const topic = topics[i];
                promises.push(this.browseTopicInIframe(topic));

                // ÊéßÂà∂Âπ∂ÂèëÊï∞ÈáèÔºåÈÅøÂÖçÂàõÂª∫ËøáÂ§öiframe
                if (promises.length >= state.concurrentThreads || i === actualEnd - 1) {
                    await Promise.allSettled(promises);
                    promises.length = 0; // Ê∏ÖÁ©∫Êï∞ÁªÑ

                    // ÊâπÊ¨°Èó¥Ê∑ªÂä†Â∞èÂª∂Ëøü
                    if (i < actualEnd - 1 && state.isBrowsing) {
                        await utils.delay(500);
                    }
                }
            }
        },

        async start() {
            if (state.isBrowsing) return;
            state.isBrowsing = true;
            ui.updateBrowseButtons(true);

            const topics = await this.getColdTopics();
            if (topics.length === 0) {
                ui.updateStatus('‚ùå Êú™ÊâæÂà∞ÂÜ∑Èó®Â∏ñÂ≠ê', 'red');
                state.isBrowsing = false;
                ui.updateBrowseButtons(false);
                return;
            }

            const targetCount = Math.min(state.unreadCount, topics.length);
            ui.updateStatus(`ÂºÄÂßãÊµèËßà ${targetCount} ‰∏™ÂÜ∑Èó®Â∏ñÂ≠ê (${state.concurrentThreads}Á∫øÁ®ã)...`, '#007cbb');

            // ‰ΩøÁî®Â§öÁ∫øÁ®ãÂπ∂ÂèëÊµèËßà
            const batchSize = state.concurrentThreads;
            for (let i = 0; i < targetCount && state.isBrowsing; i += batchSize) {
                const endIndex = Math.min(i + batchSize, targetCount);
                const currentBatch = topics.slice(i, endIndex);

                ui.updateStatus(`ÊµèËßà‰∏≠ (${i + 1}-${endIndex}/${targetCount}): ${currentBatch.map(t => t.title.substring(0, 15)).join(', ')}...`, '#007cbb');

                await this.browseTopicsConcurrently(topics, i, endIndex);

                // ÊâπÊ¨°Èó¥Ê∑ªÂä†Âª∂Ëøü
                if (endIndex < targetCount && state.isBrowsing) {
                    await utils.delay(1000);
                }
            }

            ui.updateStatus(state.isBrowsing ? `‚úÖ ÂÆåÊàêÔºÅÊµèËßà‰∫Ü ${targetCount} ‰∏™ÂÜ∑Èó®Â∏ñÂ≠ê` : '‚èπÔ∏è Â∑≤ÂÅúÊ≠¢',
                           state.isBrowsing ? 'green' : 'orange');
            state.isBrowsing = false;
            ui.updateBrowseButtons(false);
        },

        stop() {
            state.isBrowsing = false;
            ui.updateStatus('‚èπÔ∏è ÂÜ∑Èó®Â∏ñÂ≠êÊµèËßàÂ∑≤ÂÅúÊ≠¢', 'orange');
            ui.updateBrowseButtons(false);
        }
    };

    // UIÁÆ°ÁêÜÂô®
    const ui = {
        panel: null,

        // ÁºìÂ≠òDOMÂÖÉÁ¥†Êü•ËØ¢
        getCachedElement(selector) {
            if (!state.cachedElements.has(selector)) {
                const element = this.panel?.querySelector(selector);
                if (element) {
                    state.cachedElements.set(selector, element);
                }
            }
            return state.cachedElements.get(selector);
        },

        // Ê∏ÖÁêÜÂÖÉÁ¥†ÁºìÂ≠ò
        clearElementCache() {
            state.cachedElements.clear();
        },

        updateStatus(message, color = '#333') {
            const statusEl = this.getCachedElement('#status');
            if (statusEl) {
                const shortMessage = message.length > 30 ? message.substring(0, 27) + '...' : message;
                statusEl.textContent = shortMessage;
                statusEl.style.color = color;
                statusEl.title = message;
            }
        },

        // Èò≤ÊäñÁöÑÁä∂ÊÄÅÊõ¥Êñ∞ - Âª∂ËøüÂàùÂßãÂåñ
        get debouncedUpdateStatus() {
            if (!this._debouncedUpdateStatus) {
                this._debouncedUpdateStatus = utils.debounce((message, color) => {
                    this.updateStatus(message, color);
                }, 100);
            }
            return this._debouncedUpdateStatus;
        },

        // Áªü‰∏ÄÁöÑÊåâÈíÆÁä∂ÊÄÅÊõ¥Êñ∞ÂáΩÊï∞
        updateButtonState(selector, enabled) {
            const button = this.getCachedElement(selector);
            if (button) {
                button.disabled = !enabled;
                button.style.opacity = enabled ? '1' : '0.5';
                button.style.cursor = enabled ? 'pointer' : 'not-allowed';
            }
        },

        updateStopButton(enabled) {
            this.updateButtonState('#stop-btn', enabled);
        },

        updateBrowseButtons(isBrowsing) {
            this.updateButtonState('#start-browse-btn', !isBrowsing);
            this.updateButtonState('#stop-browse-btn', isBrowsing);
        },

        updateModeButtons() {
            if (!this.panel) return;
            const autoBtn = this.getCachedElement('#auto-mode-btn');
            const manualBtn = this.getCachedElement('#manual-mode-btn');
            const manualStartBtn = this.getCachedElement('#manual-start-btn');

            if (autoBtn && manualBtn) {
                autoBtn.style.background = state.isAutoMode ? '#28a745' : '#6c757d';
                autoBtn.textContent = state.isAutoMode ? '‚úì Ëá™Âä®' : 'Ëá™Âä®';
                manualBtn.style.background = !state.isAutoMode ? '#007cbb' : '#6c757d';
                manualBtn.textContent = !state.isAutoMode ? '‚úì ÊâãÂä®' : 'ÊâãÂä®';
            }

            if (manualStartBtn) {
                manualStartBtn.style.display = state.isAutoMode ? 'none' : 'block';
            }
        },

        updateCollapsed() {
            const panelBody = this.getCachedElement('#panel-body');
            const toggleBtn = this.getCachedElement('#toggle-panel');

            if (panelBody && toggleBtn) {
                panelBody.style.display = state.isCollapsed ? 'none' : 'block';
                toggleBtn.textContent = state.isCollapsed ? '‚ñ∂' : '‚ñº';
                toggleBtn.title = state.isCollapsed ? 'Â±ïÂºÄ' : 'Êî∂Ëµ∑';
            }
        },

        createPanel() {

            this.panel = document.createElement('div');
            // Ê∑ªÂä†ÂîØ‰∏ÄÊ†áËØÜÁ¨¶
            this.panel.setAttribute('data-linuxdo-helper-panel', 'true');
            this.panel.innerHTML = `
                <div style="position:fixed;top:10px;right:10px;z-index:10000;background:rgba(255,255,255,0.95);border:1px solid #28a745;border-radius:6px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1);font-family:Arial,sans-serif;width:200px;backdrop-filter:blur(5px);">
                    <div id="panel-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;cursor:pointer;">
                        <h3 style="margin:0;color:#28a745;font-size:12px;">üõ†Ô∏è LinuxDo ËæÖÂä©Â∑•ÂÖ∑</h3>
                        <div style="display:flex;align-items:center;gap:4px;">
                            <button id="toggle-panel" style="background:none;border:none;font-size:12px;cursor:pointer;color:#666;padding:2px 4px;" title="${state.isCollapsed ? 'Â±ïÂºÄ' : 'Êî∂Ëµ∑'}">
                                ${state.isCollapsed ? '‚ñ∂' : '‚ñº'}
                            </button>
                            <button id="close-panel" style="background:none;border:none;font-size:14px;cursor:pointer;color:#666;padding:0;width:16px;height:16px;" title="ÂÖ≥Èó≠">√ó</button>
                        </div>
                    </div>
                    <div id="panel-body" style="display:${state.isCollapsed ? 'none' : 'block'};">
                        ${this.createColdTopicBrowseControls()}
                        ${this.createTopicControls()}
                    </div>
                </div>
            `;

            document.body.appendChild(this.panel);
            this.bindEvents();

            // ÂàùÂßãÂåñÊåâÈíÆÁä∂ÊÄÅ
            this.updateStopButton(false);
            this.updateBrowseButtons(false);

            console.log('Èù¢ÊùøÂàõÂª∫ÂÆåÊàê');
        },

        createColdTopicBrowseControls() {
            return `
                <div style="margin-bottom:6px;border-top:1px solid #eee;padding-top:6px;">
                    <div style="font-size:10px;color:#666;margin-bottom:3px;">ÔøΩ ÈöèÊú∫ÂÜ∑Èó®Â∏ñÂ≠êÊµèËßà:</div>
                    <div style="display:flex;align-items:center;gap:4px;margin-bottom:4px;">
                        <input type="number" id="unread-count" value="${state.unreadCount}" min="1" max="100" style="width:40px;padding:2px;border:1px solid #ddd;border-radius:2px;font-size:10px;">
                        <span style="font-size:10px;color:#666;">‰∏™ËØùÈ¢ò</span>
                        <input type="number" id="concurrent-threads" value="${state.concurrentThreads}" min="1" max="10" style="width:30px;padding:2px;border:1px solid #ddd;border-radius:2px;font-size:10px;">
                        <span style="font-size:10px;color:#666;">Á∫øÁ®ã</span>
                    </div>
                    <div style="font-size:9px;color:#999;margin-bottom:4px;">Á≠õÈÄâÊ†áÂáÜ: ÊµèËßàÈáè5-800, ÂõûÂ§çÊï∞0-30</div>
                    <div style="display:flex;gap:4px;">
                        <button id="start-browse-btn" style="padding:3px 8px;background:#17a2b8;color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;flex:1;">ÂºÄÂßãÊµèËßà</button>
                        <button id="stop-browse-btn" style="padding:3px 8px;background:#dc3545;color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;flex:1;" disabled>ÂÅúÊ≠¢ÊµèËßà</button>
                    </div>
                </div>
            `;
        },

        createTopicControls() {
            const speedRadios = Object.keys(config.speeds).map(key => {
                const speedConfig = config.speeds[key];
                return `
                    <label style="display:inline-flex;align-items:center;margin-right:8px;cursor:pointer;font-size:11px;white-space:nowrap;">
                        <input type="radio" name="speed" value="${key}" ${key === state.speed ? 'checked' : ''} style="margin-right:3px;cursor:pointer;transform:scale(0.8);">
                        <span style="color:#333;">${speedConfig.name}</span>
                    </label>
                `;
            }).join('');

            return `
                <div style="margin-bottom:6px;border-top:1px solid #eee;padding-top:6px;">
                    <div style="font-size:10px;color:#666;margin-bottom:3px;">‚ö° Â¢ûÂä†Â∑≤ËØªÂ∏ñÂ≠ê:</div>
                    <div style="display:flex;gap:4px;margin-bottom:6px;">
                        <button id="auto-mode-btn" style="padding:3px 8px;background:${state.isAutoMode ? '#28a745' : '#6c757d'};color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;flex:1;">
                            ${state.isAutoMode ? '‚úì Ëá™Âä®' : 'Ëá™Âä®'}
                        </button>
                        <button id="manual-mode-btn" style="padding:3px 8px;background:${!state.isAutoMode ? '#007cbb' : '#6c757d'};color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;flex:1;">
                            ${!state.isAutoMode ? '‚úì ÊâãÂä®' : 'ÊâãÂä®'}
                        </button>
                    </div>
                    ${!state.isAutoMode ? `
                    <div style="text-align:center;margin-bottom:6px;">
                        <button id="manual-start-btn" style="padding:3px 12px;background:#007cbb;color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;">ÊâãÂä®ÂºÄÂßã</button>
                    </div>
                    ` : ''}
                    <div style="margin-bottom:6px;">
                        <div style="font-size:10px;color:#666;margin-bottom:3px;">ÈÄüÂ∫¶:</div>
                        <div style="display:flex;flex-wrap:wrap;gap:2px;">${speedRadios}</div>
                    </div>
                    <div id="status" style="padding:4px 6px;background:#f8f9fa;border-radius:3px;font-size:11px;line-height:1.3;margin-bottom:6px;min-height:16px;">Ê£ÄÊµã‰∏≠...</div>
                    <div style="text-align:center;">
                        <button id="stop-btn" style="padding:3px 8px;background:#dc3545;color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer;" disabled>ÂÅúÊ≠¢</button>
                    </div>
                </div>
            `;
        },

        bindEvents() {
            if (!this.panel) return;

            // Âü∫Êú¨ÊéßÂà∂ - ÂÖàÊ∏ÖÁêÜÁºìÂ≠òÔºåÁÑ∂ÂêéÈáçÊñ∞ÁºìÂ≠òÂÖÉÁ¥†
            this.clearElementCache();

            const closeBtn = this.getCachedElement('#close-panel');
            const toggleBtn = this.getCachedElement('#toggle-panel');
            const panelHeader = this.getCachedElement('#panel-header');

            if (closeBtn) closeBtn.onclick = () => this.removePanel();
            if (toggleBtn) {
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    stateManager.toggleCollapsed();
                };
            }
            if (panelHeader) {
                panelHeader.onclick = (e) => {
                    if (!['close-panel', 'toggle-panel'].includes(e.target.id)) {
                        stateManager.toggleCollapsed();
                    }
                };
            }

            // Ê®°ÂºèÂàáÊç¢
            const autoModeBtn = this.getCachedElement('#auto-mode-btn');
            const manualModeBtn = this.getCachedElement('#manual-mode-btn');
            const manualStartBtn = this.getCachedElement('#manual-start-btn');

            if (autoModeBtn) autoModeBtn.onclick = () => stateManager.setAutoMode(true);
            if (manualModeBtn) manualModeBtn.onclick = () => stateManager.setAutoMode(false);
            if (manualStartBtn) manualStartBtn.onclick = () => topicProcessor.processUnread();

            // ÈÄüÂ∫¶ÈÄâÊã©
            const speedRadios = this.panel?.querySelectorAll('input[name="speed"]');
            if (speedRadios) {
                speedRadios.forEach(radio => {
                    radio.onchange = (e) => {
                        if (e.target.checked) stateManager.setSpeed(e.target.value);
                    };
                });
            }

            // ÂÅúÊ≠¢ÊåâÈíÆ
            const stopBtn = this.getCachedElement('#stop-btn');
            if (stopBtn) {
                stopBtn.onclick = () => {
                    if (state.isProcessing) {
                        state.isProcessing = false;
                        this.updateStatus('‚èπÔ∏è Â∑≤ÂÅúÊ≠¢', 'orange');
                        this.updateStopButton(false);
                    }
                };
            }

            // Êú™ËØªÂ∏ñÂ≠êÊµèËßàÊéßÂà∂
            const unreadCountInput = this.getCachedElement('#unread-count');
            const concurrentThreadsInput = this.getCachedElement('#concurrent-threads');
            const startBrowseBtn = this.getCachedElement('#start-browse-btn');
            const stopBrowseBtn = this.getCachedElement('#stop-browse-btn');

            if (unreadCountInput) {
                unreadCountInput.onchange = (e) => {
                    state.unreadCount = Math.max(1, Math.min(100, parseInt(e.target.value) || 20));
                    utils.storage.set('unreadCount', state.unreadCount);
                };
            }

            if (concurrentThreadsInput) {
                concurrentThreadsInput.onchange = (e) => {
                    state.concurrentThreads = Math.max(1, Math.min(10, parseInt(e.target.value) || 3));
                    utils.storage.set('concurrentThreads', state.concurrentThreads);
                };
            }

            if (startBrowseBtn) startBrowseBtn.onclick = () => coldTopicBrowser.start();
            if (stopBrowseBtn) stopBrowseBtn.onclick = () => coldTopicBrowser.stop();
        },

        removePanel() {
            // Ê∏ÖÁêÜÂÖÉÁ¥†ÁºìÂ≠ò
            this.clearElementCache();

            // ÁßªÈô§ÂΩìÂâçÈù¢Êùø
            if (this.panel) {
                this.panel.remove();
                this.panel = null;
            }
        }
    };

    // Â∫îÁî®ÁÆ°ÁêÜÂô®
    const app = {
        init() {
            if (!location.hostname.includes('linux.do')) return;

            console.log('üöÄ LinuxDo ËæÖÂä©Â∑•ÂÖ∑ÂêØÂä®');

            stateManager.init();

            // ÂàùÂßãÂåñÂΩìÂâçËØùÈ¢òID
            state.lastTopicId = utils.getTopicId();

            ui.createPanel();

            // ÂáèÂ∞ëÂàùÂßãÂåñÂª∂ËøüÔºåËÆ©Èù¢ÊùøÊõ¥Âø´ÊòæÁ§∫
            setTimeout(() => {
                const pageType = utils.getPageType();
                if (pageType === 'topic') {
                    if (state.isAutoMode) {
                        topicProcessor.checkAndProcess();
                    } else {
                        ui.updateStatus('‚úÖ ÊâãÂä®Ê®°ÂºèÂ∑≤Â∞±Áª™', 'green');
                    }
                } else {
                    ui.updateStatus('‚úÖ LinuxDo ËæÖÂä©Â∑•ÂÖ∑Â∑≤Â∞±Áª™', 'green');
                }
            }, CONSTANTS.DELAYS.STATUS_UPDATE);

            this.setupUrlMonitoring();
        },

        cleanup() {
            // Ê∏ÖÁêÜÊâÄÊúâÂèØËÉΩÁöÑÈÅóÁïôÂÖÉÁ¥†
            ui.removePanel();

            // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
            this.cleanupEventListeners();

            // Ê∏ÖÁêÜÂÖÉÁ¥†ÁºìÂ≠ò
            ui.clearElementCache();

            console.log('Ê∏ÖÁêÜÂÆåÊàê');
        },

        setupUrlMonitoring() {
            let lastUrl = location.href;
            let checkCount = 0;

            const checkUrlChange = () => {
                if (location.href !== lastUrl && !state.isProcessing && !state.isBrowsing) {
                    const currentTopicId = utils.getTopicId();
                    const needReinit = currentTopicId !== state.lastTopicId;

                    console.log('Ê£ÄÊµãÂà∞È°µÈù¢ÂèòÂåñ', {
                        oldUrl: lastUrl,
                        newUrl: location.href,
                        oldTopicId: state.lastTopicId,
                        newTopicId: currentTopicId,
                        needReinit
                    });

                    lastUrl = location.href;
                    state.lastUrl = lastUrl;

                    // Âè™Êõ¥Êñ∞Áä∂ÊÄÅÔºå‰∏çÈáçÊñ∞ÂàùÂßãÂåñÈù¢Êùø
                    console.log('È°µÈù¢ÂèòÂåñÔºåÊõ¥Êñ∞Áä∂ÊÄÅ');
                    state.lastTopicId = currentTopicId;

                    if (utils.getPageType() === 'topic') {
                        if (state.isAutoMode) {
                            setTimeout(() => {
                                if (!state.isProcessing) {
                                    topicProcessor.checkAndProcess();
                                }
                            }, CONSTANTS.DELAYS.AUTO_CHECK);
                        } else {
                            ui.updateStatus('‚úÖ ÊâãÂä®Ê®°ÂºèÂ∑≤Â∞±Áª™', 'green');
                        }
                    } else {
                        ui.updateStatus('‚úÖ LinuxDo ËæÖÂä©Â∑•ÂÖ∑Â∑≤Â∞±Áª™', 'green');
                    }

                    // ÈáçÁΩÆÊ£ÄÊü•ËÆ°Êï∞
                    checkCount = 0;
                } else {
                    // Â¢ûÂä†Ê£ÄÊü•ËÆ°Êï∞ÔºåÁî®‰∫éÂä®ÊÄÅË∞ÉÊï¥Ê£ÄÊü•Èó¥Èöî
                    checkCount++;
                }
            };

            // Êô∫ËÉΩURLÁõëÊéß - Ê†πÊçÆÊ¥ªÂä®ÊÉÖÂÜµË∞ÉÊï¥Ê£ÄÊü•È¢ëÁéá
            const startUrlMonitoring = () => {
                if (state.urlCheckInterval) {
                    clearInterval(state.urlCheckInterval);
                }

                state.urlCheckInterval = setInterval(() => {
                    checkUrlChange();

                    // Â¶ÇÊûúÈïøÊó∂Èó¥Ê≤°ÊúâURLÂèòÂåñÔºåÈôç‰ΩéÊ£ÄÊü•È¢ëÁéá
                    if (checkCount > 30) { // 30ÁßíÊó†ÂèòÂåñ
                        clearInterval(state.urlCheckInterval);
                        // ÂàáÊç¢Âà∞‰ΩéÈ¢ëÊ£ÄÊü•Ê®°Âºè
                        state.urlCheckInterval = setInterval(checkUrlChange, 5000); // 5ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
                    }
                }, 1000);
            };

            startUrlMonitoring();

            // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®Âπ∂ËÆ∞ÂΩïÔºå‰æø‰∫éÊ∏ÖÁêÜ
            const addEventListenerWithCleanup = (target, event, handler, options) => {
                target.addEventListener(event, handler, options);
                state.eventListeners.push({ target, event, handler, options });
            };

            // ÁõëÂê¨ÊµèËßàÂô®ÂâçËøõÂêéÈÄÄ
            addEventListenerWithCleanup(window, 'popstate', () => {
                setTimeout(checkUrlChange, 100);
                startUrlMonitoring(); // ÈáçÊñ∞ÂêØÂä®È´òÈ¢ëÁõëÊéß
            });

            // ÁõëÂê¨ÈìæÊé•ÁÇπÂáª
            addEventListenerWithCleanup(document, 'click', (e) => {
                const link = e.target.closest('a');
                if (link?.href?.includes('/t/topic/')) {
                    setTimeout(checkUrlChange, 500);
                    startUrlMonitoring(); // ÈáçÊñ∞ÂêØÂä®È´òÈ¢ëÁõëÊéß
                }
            });

            // ÁõëÂê¨È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÔºå‰ºòÂåñÊÄßËÉΩ
            addEventListenerWithCleanup(document, 'visibilitychange', () => {
                if (document.hidden) {
                    // È°µÈù¢ÈöêËóèÊó∂ÂÅúÊ≠¢URLÊ£ÄÊü•
                    if (state.urlCheckInterval) {
                        clearInterval(state.urlCheckInterval);
                        state.urlCheckInterval = null;
                    }
                } else {
                    // È°µÈù¢ÊòæÁ§∫Êó∂ÊÅ¢Â§çURLÊ£ÄÊü•
                    startUrlMonitoring();
                }
            });
        },

        // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
        cleanupEventListeners() {
            state.eventListeners.forEach(({ target, event, handler, options }) => {
                target.removeEventListener(event, handler, options);
            });
            state.eventListeners = [];

            if (state.urlCheckInterval) {
                clearInterval(state.urlCheckInterval);
                state.urlCheckInterval = null;
            }
        }
    };



    // ÂêØÂä®Â∫îÁî®
    app.init();

    // Êö¥Èú≤Âà∞ÂÖ®Â±Ä‰ΩúÁî®ÂüüÔºàÁî®‰∫éË∞ÉËØïÔºâ
    window.linuxDoHelper = {
        state,
        config,
        utils,
        stateManager,
        topicProcessor,
        coldTopicBrowser,
        ui,
        app
    };


})();
